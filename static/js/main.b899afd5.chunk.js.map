{"version":3,"sources":["Map/MapProvider.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["INITIAL_VIEW_STATE","latitude","longitude","zoom","bearing","pitch","transitionInterpolator","FlyToInterpolator","transitionDuration","INITIAL_HOVER_STATE","mapFilterCoords","pinCoords","MapContext","createContext","viewState","hoverState","mapRef","map","pins","features","MapProvider","children","React","useState","setPins","setViewState","setHoverState","useRef","Provider","value","current","getMap","useMapState","context","useContext","Error","WorkingBikes","lazy","App","basename","process","Suspense","fallback","path","component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"yNAoBMA,EAA6C,CAClDC,SAAU,QACVC,WAAY,OACZC,KAAM,EACNC,QAAS,EACTC,MAAO,GACPC,uBAAwB,IAAIC,IAC5BC,mBAAoB,KAGfC,EAAkC,CACvCC,gBAAiB,CAAC,EAAG,GACrBC,UAAW,CAAC,EAAG,IAGHC,EAAaC,wBAAqB,CAC9CC,UAAWd,EACXe,WAAYN,EACZO,OAAQ,KACRC,IAAK,KACLC,KAAM,CACLC,SAAU,MA+BGC,IA3BK,SAAC,GAAkD,IAAhDC,EAA+C,EAA/CA,SAA+C,EAC7CC,IAAMC,WADuC,mBAC9DL,EAD8D,KACxDM,EADwD,OAEnCF,IAAMC,SACvCvB,GAHoE,mBAE9Dc,EAF8D,KAEnDW,EAFmD,OAKjCH,IAAMC,SACzCd,GANoE,mBAK9DM,EAL8D,KAKlDW,EALkD,KAQ/DV,EAASM,IAAMK,OAAuB,MAC5C,OACC,kBAACf,EAAWgB,SAAZ,CACCC,MAAO,CACNb,SACAC,IAAKD,EAAOc,QAAUd,EAAOc,QAAQC,SAAW,KAChDb,OACAM,UACAV,YACAW,eACAV,aACAW,kBAGAL,IAOG,IAAMW,EAAc,WAC1B,IAAMC,EAAUC,qBAAkBtB,GAClC,GAAuB,qBAAZqB,GAAsC,MAAXA,EACrC,MAAM,IAAIE,MAAM,0CAGjB,OAAOF,I,gMC3EFG,EAAed,IAAMe,MAAK,kBAAM,uDAgBvBC,EAdO,WACrB,OACC,kBAAC,IAAD,CAAQC,SAAUC,kBACjB,kBAACpB,EAAA,EAAD,KACC,kBAAC,IAAMqB,SAAP,CAAgBC,SAAU,MACzB,kBAAC,IAAD,KACC,kBAAC,IAAD,CAAOC,KAAK,IAAIC,UAAWR,SCDbS,QACU,cAA7BC,OAAOC,SAASC,UAEc,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACxB,2DCZHC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SDmI5C,kBAAmBC,WACtBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GAClCA,EAAaC,kB","file":"static/js/main.b899afd5.chunk.js","sourcesContent":["import { PinFeatures, HoverState } from './mapTypes';\nimport InteractiveMap, {\n\tViewState,\n\tViewportProps,\n\tFlyToInterpolator,\n} from 'react-map-gl';\nimport MapboxGl from 'mapbox-gl';\nimport React, { useContext, createContext } from 'react';\n\ninterface State {\n\thoverState: HoverState;\n\tmap: MapboxGl.Map | null;\n\tmapRef: React.RefObject<InteractiveMap> | null;\n\tpins: PinFeatures;\n\tsetHoverState?: React.Dispatch<React.SetStateAction<HoverState>>;\n\tsetPins?: Function;\n\tsetViewState?: React.Dispatch<React.SetStateAction<Partial<ViewportProps>>>;\n\tviewState: Partial<ViewState>;\n}\n\nconst INITIAL_VIEW_STATE: Partial<ViewportProps> = {\n\tlatitude: 40.7128,\n\tlongitude: -74.006,\n\tzoom: 4,\n\tbearing: 0,\n\tpitch: 30,\n\ttransitionInterpolator: new FlyToInterpolator(),\n\ttransitionDuration: 1000,\n};\n\nconst INITIAL_HOVER_STATE: HoverState = {\n\tmapFilterCoords: [0, 0],\n\tpinCoords: [0, 0],\n};\n\nexport const MapContext = createContext<State>({\n\tviewState: INITIAL_VIEW_STATE,\n\thoverState: INITIAL_HOVER_STATE,\n\tmapRef: null,\n\tmap: null,\n\tpins: {\n\t\tfeatures: [],\n\t},\n});\n\nconst MapProvider = ({ children }: { children?: React.ReactNode }) => {\n\tconst [pins, setPins] = React.useState();\n\tconst [viewState, setViewState] = React.useState<Partial<ViewportProps>>(\n\t\tINITIAL_VIEW_STATE\n\t);\n\tconst [hoverState, setHoverState] = React.useState<HoverState>(\n\t\tINITIAL_HOVER_STATE\n\t);\n\tconst mapRef = React.useRef<InteractiveMap>(null);\n\treturn (\n\t\t<MapContext.Provider\n\t\t\tvalue={{\n\t\t\t\tmapRef,\n\t\t\t\tmap: mapRef.current ? mapRef.current.getMap() : null,\n\t\t\t\tpins,\n\t\t\t\tsetPins,\n\t\t\t\tviewState,\n\t\t\t\tsetViewState,\n\t\t\t\thoverState,\n\t\t\t\tsetHoverState,\n\t\t\t}}\n\t\t>\n\t\t\t{children}\n\t\t</MapContext.Provider>\n\t);\n};\n\nexport default MapProvider;\n\nexport const useMapState = () => {\n\tconst context = useContext<State>(MapContext);\n\tif (typeof context === 'undefined' || context == null) {\n\t\tthrow new Error('useMap must be used with a MapProvider');\n\t}\n\n\treturn context;\n};\n\nexport const withMap = <P extends object>(Component: React.ComponentType<P>) =>\n\tclass WithMap extends React.Component<P> {\n\t\tmap = (context: State) => {\n\t\t\tconst mapRef = context ? context.mapRef : null;\n\t\t\treturn mapRef && mapRef.current ? mapRef.current.getMap() : null;\n\t\t};\n\t\trender() {\n\t\t\treturn (\n\t\t\t\t<MapContext.Consumer>\n\t\t\t\t\t{context => {\n\t\t\t\t\t\tconst map = this.map(context);\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t<Component\n\t\t\t\t\t\t\t\t{...this.props}\n\t\t\t\t\t\t\t\thoverState={context.hoverState}\n\t\t\t\t\t\t\t\tmap={map}\n\t\t\t\t\t\t\t\tmapIsLoaded={map && map.loaded()}\n\t\t\t\t\t\t\t\tpins={context.pins}\n\t\t\t\t\t\t\t\tsetHoverState={context.setHoverState}\n\t\t\t\t\t\t\t\tsetPins={context.setPins}\n\t\t\t\t\t\t\t\tsetViewState={context.setViewState}\n\t\t\t\t\t\t\t\tviewState={context.viewState}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t);\n\t\t\t\t\t}}\n\t\t\t\t</MapContext.Consumer>\n\t\t\t);\n\t\t}\n\t};\n","import React from 'react';\nimport './App.css';\nimport MapProvider from 'Map/MapProvider';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\n\nconst WorkingBikes = React.lazy(() => import('WorkingBikes/WorkingBikes'));\n\nconst App: React.FC = () => {\n\treturn (\n\t\t<Router basename={process.env.PUBLIC_URL}>\n\t\t\t<MapProvider>\n\t\t\t\t<React.Suspense fallback={null}>\n\t\t\t\t\t<Switch>\n\t\t\t\t\t\t<Route path=\"/\" component={WorkingBikes} />\n\t\t\t\t\t</Switch>\n\t\t\t\t</React.Suspense>\n\t\t\t</MapProvider>\n\t\t</Router>\n\t);\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n\twindow.location.hostname === 'localhost' ||\n\t\t// [::1] is the IPv6 localhost address.\n\t\twindow.location.hostname === '[::1]' ||\n\t\t// 127.0.0.1/8 is considered localhost for IPv4.\n\t\twindow.location.hostname.match(\n\t\t\t/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n\t\t)\n);\n\ntype Config = {\n\tonSuccess?: (registration: ServiceWorkerRegistration) => void;\n\tonUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n\tif (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n\t\t// The URL constructor is available in all browsers that support SW.\n\t\tconst publicUrl = new URL(\n\t\t\t(process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n\t\t\twindow.location.href\n\t\t);\n\t\tif (publicUrl.origin !== window.location.origin) {\n\t\t\t// Our service worker won't work if PUBLIC_URL is on a different origin\n\t\t\t// from what our page is served on. This might happen if a CDN is used to\n\t\t\t// serve assets; see https://github.com/facebook/create-react-app/issues/2374\n\t\t\treturn;\n\t\t}\n\n\t\twindow.addEventListener('load', () => {\n\t\t\tconst swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n\t\t\tif (isLocalhost) {\n\t\t\t\t// This is running on localhost. Let's check if a service worker still exists or not.\n\t\t\t\tcheckValidServiceWorker(swUrl, config);\n\n\t\t\t\t// Add some additional logging to localhost, pointing developers to the\n\t\t\t\t// service worker/PWA documentation.\n\t\t\t\tnavigator.serviceWorker.ready.then(() => {\n\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t'This web app is being served cache-first by a service ' +\n\t\t\t\t\t\t\t'worker. To learn more, visit https://bit.ly/CRA-PWA'\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Is not localhost. Just register service worker\n\t\t\t\tregisterValidSW(swUrl, config);\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n\tnavigator.serviceWorker\n\t\t.register(swUrl)\n\t\t.then(registration => {\n\t\t\tregistration.onupdatefound = () => {\n\t\t\t\tconst installingWorker = registration.installing;\n\t\t\t\tif (installingWorker == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tinstallingWorker.onstatechange = () => {\n\t\t\t\t\tif (installingWorker.state === 'installed') {\n\t\t\t\t\t\tif (navigator.serviceWorker.controller) {\n\t\t\t\t\t\t\t// At this point, the updated precached content has been fetched,\n\t\t\t\t\t\t\t// but the previous service worker will still serve the older\n\t\t\t\t\t\t\t// content until all client tabs are closed.\n\t\t\t\t\t\t\tconsole.log(\n\t\t\t\t\t\t\t\t'New content is available and will be used when all ' +\n\t\t\t\t\t\t\t\t\t'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Execute callback\n\t\t\t\t\t\t\tif (config && config.onUpdate) {\n\t\t\t\t\t\t\t\tconfig.onUpdate(registration);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// At this point, everything has been precached.\n\t\t\t\t\t\t\t// It's the perfect time to display a\n\t\t\t\t\t\t\t// \"Content is cached for offline use.\" message.\n\t\t\t\t\t\t\tconsole.log('Content is cached for offline use.');\n\n\t\t\t\t\t\t\t// Execute callback\n\t\t\t\t\t\t\tif (config && config.onSuccess) {\n\t\t\t\t\t\t\t\tconfig.onSuccess(registration);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t})\n\t\t.catch(error => {\n\t\t\tconsole.error('Error during service worker registration:', error);\n\t\t});\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n\t// Check if the service worker can be found. If it can't reload the page.\n\tfetch(swUrl)\n\t\t.then(response => {\n\t\t\t// Ensure service worker exists, and that we really are getting a JS file.\n\t\t\tconst contentType = response.headers.get('content-type');\n\t\t\tif (\n\t\t\t\tresponse.status === 404 ||\n\t\t\t\t(contentType != null && contentType.indexOf('javascript') === -1)\n\t\t\t) {\n\t\t\t\t// No service worker found. Probably a different app. Reload the page.\n\t\t\t\tnavigator.serviceWorker.ready.then(registration => {\n\t\t\t\t\tregistration.unregister().then(() => {\n\t\t\t\t\t\twindow.location.reload();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Service worker found. Proceed as normal.\n\t\t\t\tregisterValidSW(swUrl, config);\n\t\t\t}\n\t\t})\n\t\t.catch(() => {\n\t\t\tconsole.log(\n\t\t\t\t'No internet connection found. App is running in offline mode.'\n\t\t\t);\n\t\t});\n}\n\nexport function unregister() {\n\tif ('serviceWorker' in navigator) {\n\t\tnavigator.serviceWorker.ready.then(registration => {\n\t\t\tregistration.unregister();\n\t\t});\n\t}\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}